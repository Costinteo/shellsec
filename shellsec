#!/usr/bin/env bash

# +-----------------------------------------------------------------+
# |  ______ _     _ _______ _       _        ______ _______ _______ |
# | / _____) |   | |  _____) |     | |      / _____)  _____|  _____)|
# |( (____ | |___| | |___  | |     | |     ( (____ | |___  | |      |
# | \____ \|  ___  |  ___) | |     | |      \____ \|  ___) | |      |
# | _____) ) |   | | |_____| |_____| |_____ _____) ) |_____| |_____ |
# |(______/|_|   |_|_______)_______)_______)______/|_______)_______)|
# +-----------------------------------------------------------------+
# |        Bash tool to generate and manage secure passwords        | 
# |                                                                 |
# |                  https://github.com/Costinteo                   |
# |                           GNU GPL v3                            |
# +-----------------------------------------------------------------+

# TODO
# warn when trying to change MODE after set
# copy to clipboard
# interactive mode
# replace grep calls with pure bash
# replacement for tr?


# === CLI Arguments ===
# - Flags -
MODE=0     # 0 -> NONE, 1 -> STORE, 2 -> LOAD, 3 -> ALL_PLATFORMS
USAGE=0    # 1 -> PRINT USAGE
LICENSE=0  # 1 -> PRINT LICENSE
COLOR=1    # 0 -> COLORS OFF, 1 = COLORS ON
VERBOSE=0  # 1 -> VERBOSE OUTPUT
COPY=0     # 1 -> COPY TO CLIPBOARD
PRINT=0    # 1 -> PRINT GENERATED PASSWORD

# - Arguments -
PASSLEN=0
PLATFORM=""

# === Constants ===
LICENSE_LINK="https://www.gnu.org/licenses/gpl-3.0.txt"

SECRET_FILE="/home/$USER/.shellsec_secret"

ENCRYPTION="aes-256-cbc"

# - Colors -
GREEN='\033[32;01m'
YELLOW='\033[33;01m'
RED='\033[1;31m'
BLUE='\033[34;01m'
PURPLE='\033[35m'
TEXT='\033[0m'


usage() {
	cat <<- _end_of_usage
	Usage: shellsec [OPTIONS]...
	Bash tool to generate and manage secure passwords.
	Run without arguments for interactive mode.

	Options:
	    -h, --help                print this text and exit
	        --license             print license and exit
	        --no-color            suppress colored output
	    -p, --pass  <LEN>         generate random pass with <LEN> chars
	    -s, --store <PLATFORM>    store pass for <PLATFORM>
	    -l, --load  <PLATFORM>    load pass for <PLATFORM>
	    -a, --all-platforms       decrypt and print all platforms
	    -c, --copy                copy to clipboard generated / requested pass
	        --print               print pass after generated

	The script is written by Costinteo. <https://github.com/Costinteo>
	Licensed under GNU GPL v3. <$LICENSE_LINK>
	_end_of_usage

	exit 0
}

# always grabs license from the internet
license() {
	wget -q --output-document - "$LICENSE_LINK"
	[ $? -ne 0 ] && printf "${RED}License couldn't be fetched! Check internet connection...${TEXT}\n"
	exit 0
}

checkReqs() {
	openssl version 1>/dev/null 2>&1
	[ $? -ne 0 ] && printf "${RED}openssl is not installed...${TEXT}\n" && exit 1
}

suppressColors() {
	GREEN=''
	YELLOW=''
	RED=''
	BLUE=''
	PURPLE=''
	TEXT=''
}

# prints usage error message in red and exits
# used when parsing args
usageError() {
	local msg=$1
	1>&2 printf "${RED}$msg${TEXT} See --help for usage.\n" 
	exit 1
}

printError() {
	local msg=$1
	1>&2 printf "${RED}$msg${TEXT}\n"
}

interrupt() {
	printf "\n${YELLOW}Script interrupted...${TEXT}\n"
	# if echo disabled, make sure it is re-enabled
	stty echo
	exit 1
}

getArgs() {
	
	[ $# -eq 0 ] && usage

	while [ $# -ne 0 ]
	do
		case "$1" in
		"-h"|"--help")
			USAGE=1
			;;

		"--license")
			LICENSE=1
			;;

		"--no-color")
			COLOR=0
			;;

		"-p"|"--pass")
			local numeric='^[0-9]+$'
			[[ ! "$2" =~ $numeric ]] && usageError "Invalid length for password!"
			PASSLEN=$2
			shift
			;;

		"-s"|"--store")
			MODE=1
			;;

		"-l"|"--load")
			MODE=2
			;;

		"-a"|"--all-platforms")
			MODE=3
			;;

		"-c"|"--copy")
			COPY=1
			;;

		"--print")
			PRINT=1
			;;
		*)
			usageError "Unkown argument $1!"
			;;
		esac

		# if MODE just read, get PLATFORM along with it, if currently empty
		# if MODE is 3 -> no PLATFORM argument
		[ $MODE -gt 0 ] && [ $MODE -lt 3 ] && [ -z "$PLATFORM" ] && PLATFORM=${2,,} && shift

		shift

	done
}

createSecretFile() {
	touch "$SECRET_FILE"
	chmod 600 "$SECRET_FILE"
}

# $1 = password len
generatePass() {
	local len=$1
	local requiredNumbers=$(( $len/5 ))
	local requiredSymbols=$(( $len/5 ))
	while :
	do
		local pass=$(</dev/urandom tr -dc '[:graph:]' | head -c $len)
		# this is not implemented too nicely
		# could be nicer if I would collect numbers and symbols
		# and maybe randomly spread them out the pass
		# so it doesn't wait for urandom to find a contiguous string with those conditions
		local numericCount=$(tr -d -c '[:digit:]' <<<"$pass" | wc -c) # wc could be switched for bash expansion
		local symbolCount=$(tr -d '[:alnum:]' <<<"$pass" | wc -c)
		[ $numericCount -gt $requiredNumbers ] && [ $symbolCount -gt $requiredSymbols ] && break
	done
	printf "%s" "$pass"
}

# $1 = platform to search for
platformExists() {
	local platform=$1
	grep -ioP -- "$platform" "$SECRET_FILE" 1>/dev/null 2>&1
	return $?
}

readSecret() {
	stty -echo
	read $1
	stty echo
	echo
}

# $1 = platform to store pass for
# $2 = password to store
storePass() {
	local platform=$1
	local password=$2

	if [ ! -f "$SECRET_FILE" ]; then
		createSecretFile
	else
		platformExists "$platform"
		[ $? -eq 0 ] && printError "Password already saved for platform $platform!" && return 1
	fi

	# if no password passed, grab pass from stdin
	if [ -z "$password" ]; then
		1>&2 printf "Password for $platform: "
		readSecret password
	fi

	printf "$platform: " >> "$SECRET_FILE"
	
	if [ -z "$SHELLSEC_MASTERPASS" ]; then
		printf "%s" "$password" | openssl enc -"$ENCRYPTION" -salt -pbkdf2 -a >> "$SECRET_FILE"
	else
		printf "%s" "$password" | openssl enc -"$ENCRYPTION" -salt -pbkdf2 -pass env:SHELLSEC_MASTERPASS -a >> "$SECRET_FILE"
	fi

}

# $1 = platform to load pass for
loadPass() {
	local platform=$1
	
	local line=$(grep -iP -- "^${platform}:" "$SECRET_FILE")
	
	[ $? -ne 0 ] && printError "No password found for ${platform}..." return 1
	
	if [ -z "$SHELLSEC_MASTERPASS" ]; then
		echo $line | cut -d " " -f 2 | openssl enc -"$ENCRYPTION" -salt -pbkdf2 -a -d
	else
		echo $line | cut -d " " -f 2 | openssl enc -"$ENCRYPTION" -salt -pbkdf2 -pass env:SHELLSEC_MASTERPASS -a -d
	fi
}

printAllPlatforms() {
	[ ! -f "$SECRET_FILE" ] && printError "No password file found!" && return 1
	cat "$SECRET_FILE" | grep -oP --color=none -- "^[^:\s]+"
}

# does all the magic
shellsec() {

	[ $USAGE -eq 1 ] && usage
	[ $LICENSE -eq 1 ] && license
	[ $COLOR -eq 0 ] && suppressColors

	[ $PASSLEN -ne 0 ] && local pass=$(generatePass "$PASSLEN")

	# 1 -> STORE PASS
	# 2 -> LOAD PASS
	# 3 -> PRINT ALL PLATFORMS
	case "$MODE" in 
	0)
		if [ -n "$pass" ]; then printf "${BLUE}Generated pass:${TEXT} %s\n" "$pass"
		else usageError "No action chosen!" 
		fi
		;;
	1)
		storePass "$PLATFORM" "$pass"
		[ $? -eq 0 ] && [ $PRINT -eq 1 ] && printf "$pass\n"
		;;
	2)
		local pass=$(loadPass "$PLATFORM")
		[ $? -eq 0 ] && printf "$pass\n"
		;;
	3)
		printAllPlatforms
		;;
	*)
		printError "Unexpected error has occured. Exiting..."
		exit 1;
		;;
	esac

}

# === MAIN ===

trap interrupt SIGINT

checkReqs
getArgs "$@"
shellsec
